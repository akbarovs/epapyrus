// Generated by CoffeeScript 1.6.2
(function() {
  var Arrow, ArrowParams, EndEvent, Scene, Shape, ShapeConstants, ShapeFactory, StartEvent, UserTask, Utils, XYPoint, loadMenu, loadPaper, loadTemplates,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ArrowParams = {
    LENGTH: 10,
    DEGREE: 155
  };

  Arrow = (function() {
    Arrow.prototype.points = {};

    function Arrow(id, shapeFrom, shapeTo) {
      this.id = id;
      this.shapeFrom = shapeFrom;
      this.shapeTo = shapeTo;
      this.drawArrow();
    }

    Arrow.prototype.drawArrow = function() {
      var arrowEnd, arrowPath, end, intersections, lineEnd, linePath, mX, mY, middle, path, pth, segments, start, startPoint;

      this.from = this.shapeFrom.center();
      this.to = this.shapeTo.center();
      end = new $p.Point(this.to.x, this.to.y);
      start = new $p.Point(this.from.x, this.from.y);
      mX = this.to.x;
      mY = this.from.y;
      middle = new $p.Point(mX, mY);
      segments = [start, middle, end];
      startPoint = middle;
      if (this.shapeTo.visiblePath().contains(middle) || this.shapeFrom.visiblePath().contains(middle)) {
        segments = [start, end];
        startPoint = this.from;
      }
      linePath = new $p.Path(segments);
      linePath.strokeColor = 'black';
      linePath.strokeWidth = 1;
      pth = this.shapeTo.visiblePath();
      intersections = linePath.getIntersections(pth);
      if (intersections[0] != null) {
        lineEnd = intersections[0].point;
        arrowEnd = Utils.minus(lineEnd, startPoint).normalize(ArrowParams.LENGTH);
        arrowPath = new $p.Path([Utils.add(lineEnd, arrowEnd.rotate(ArrowParams.DEGREE)), lineEnd, Utils.add(lineEnd, arrowEnd.rotate(-1 * ArrowParams.DEGREE))]);
        arrowPath.strokeWidth = 0.75;
        arrowPath.fillColor = 'black';
        path = new $p.Group([linePath, arrowPath]);
      } else {
        linePath.remove();
      }
      if (path != null) {
        path.sendToBack();
      }
      return this.points = {
        start: linePath.firstSegment.point,
        end: linePath.lastSegment.point,
        ptr: arrowPath,
        linePath: linePath
      };
    };

    Arrow.prototype.move = function(isStartPt, pos, shape) {
      var _ref, _ref1;

      if ((_ref = this.points.ptr) != null) {
        _ref.remove();
      }
      if ((_ref1 = this.points.linePath) != null) {
        _ref1.remove();
      }
      this.shape;
      return this.drawArrow();
    };

    return Arrow;

  })();

  loadPaper = function() {
    paper.setup('editorCanvas');
    return window.$p = paper;
  };

  $(function() {
    var a, b, c, i, scene, selected, toConnect, tool;

    loadPaper();
    window.$t = $.render;
    loadTemplates('./templates.html');
    loadMenu('./menu.json');
    a = new StartEvent("test", {
      x: 100,
      y: 100
    });
    b = new EndEvent("test2", {
      x: 350,
      y: 250
    });
    c = new UserTask("userTask", {
      x: 200,
      y: 100
    });
    scene = new Scene;
    scene.add(a);
    scene.add(b);
    scene.add(c);
    scene.draw();
    a.from(c);
    c.from(b);
    i = 1;
    i++;
    $p.view.viewSize = new $p.Size(1200, 1200);
    $p.view.draw();
    tool = new $p.Tool();
    selected = void 0;
    toConnect = void 0;
    tool.onMouseDown = function(event) {
      var element;

      selected = event.item;
      $p.project.activeLayer.selected = false;
      if (selected) {
        selected.editorObj.select();
      }
      if (event.modifiers.shift && !selected) {
        element = new UserTask("userTask" + i, {
          x: event.point.x,
          y: event.point.y
        });
        i++;
        element.draw();
      }
      if (event.modifiers.option && selected) {
        if (!toConnect) {
          return toConnect = selected;
        } else {
          toConnect.editorObj.from(selected.editorObj);
          return toConnect = void 0;
        }
      }
    };
    return tool.onMouseDrag = function(event) {
      if (selected) {
        selected.position.x += event.delta.x;
        selected.position.y += event.delta.y;
        return selected.editorObj.move(event.delta);
      }
    };
  });

  ShapeConstants = {
    strokeColor: 'black'
  };

  XYPoint = (function() {
    function XYPoint(x, y) {
      this.x = x;
      this.y = y;
    }

    return XYPoint;

  })();

  Scene = (function() {
    function Scene(objects) {
      this.objects = objects != null ? objects : [];
    }

    Scene.prototype.add = function(object) {
      return this.objects.push(object);
    };

    Scene.prototype.draw = function() {
      var object, _i, _len, _ref, _results;

      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        _results.push(object.draw());
      }
      return _results;
    };

    return Scene;

  })();

  Shape = (function() {
    Shape.prototype.type = void 0;

    Shape.prototype.size = void 0;

    Shape.prototype.fromArrows = void 0;

    Shape.prototype.toArrows = void 0;

    Shape.prototype.path = void 0;

    function Shape(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      this.fromArrows = [];
      this.toArrows = [];
      this.size = {};
      this.path = void 0;
    }

    Shape.prototype.draw = function() {
      throw new Error("Unsupported");
    };

    Shape.prototype.visiblePath = function() {
      var pth;

      if (this.path.children) {
        return pth = this.path.children[0];
      } else {
        return pth = this.path;
      }
    };

    Shape.prototype.center = function() {
      return this.path.bounds.center;
    };

    Shape.prototype.from = function(shape) {
      var arrow;

      arrow = new Arrow("", this, shape);
      this.fromArrows.push(arrow);
      return shape.toArrows.push(arrow);
    };

    Shape.prototype.select = function() {
      return this.visiblePath().selected = true;
    };

    Shape.prototype.move = function(pos) {
      var arrow, _i, _j, _len, _len1, _ref, _ref1, _results;

      _ref = this.fromArrows;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arrow = _ref[_i];
        arrow.move(true, pos, this);
      }
      _ref1 = this.toArrows;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        arrow = _ref1[_j];
        _results.push(arrow.move(false, pos, this));
      }
      return _results;
    };

    return Shape;

  })();

  StartEvent = (function(_super) {
    __extends(StartEvent, _super);

    function StartEvent(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      StartEvent.__super__.constructor.call(this, this.id, this.coord, this.data);
      this.type = 'start-event';
      this.size.r = 15;
    }

    StartEvent.prototype.draw = function() {
      this.path = new $p.Path.Circle(new $p.Point(this.coord.x, this.coord.y), this.size.r);
      this.path.fillColor = 'black';
      return this.path.editorObj = this;
    };

    return StartEvent;

  })(Shape);

  EndEvent = (function(_super) {
    __extends(EndEvent, _super);

    function EndEvent(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      EndEvent.__super__.constructor.call(this, this.id, this.coord, this.data);
      this.type = 'end-event';
      this.size.r = 15;
    }

    EndEvent.prototype.draw = function() {
      this.path = new $p.Path.Circle(new $p.Point(this.coord.x, this.coord.y), this.size.r);
      this.path.fillColor = 'white';
      this.path.strokeColor = 'black';
      return this.path.editorObj = this;
    };

    return EndEvent;

  })(Shape);

  UserTask = (function(_super) {
    __extends(UserTask, _super);

    UserTask.prototype.path = void 0;

    function UserTask(id, coord, data) {
      var path;

      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      UserTask.__super__.constructor.call(this, this.id, this.coord, this.data);
      path = void 0;
      this.type = 'user-task';
      this.size = {
        x: 100,
        y: 60
      };
    }

    UserTask.prototype.draw = function() {
      var g, pth, rect, txt;

      rect = new $p.Rectangle(new $p.Point(this.coord.x, this.coord.y), new $p.Size(this.size));
      pth = new $p.Path.RoundRectangle(rect, new $p.Size(5, 5));
      pth.strokeColor = 'black';
      pth.fillColor = '#DCECB5';
      txt = new $p.PointText(pth.bounds.leftCenter);
      txt.fillColor = 'black';
      txt.content = this.id;
      txt.bounds.x = txt.bounds.x + 10;
      txt.position.y = txt.bounds.y + txt.bounds.height / 1.5;
      g = new $p.Group([pth, txt]);
      g.applyMatrix = true;
      this.path = g;
      return this.path.editorObj = this;
    };

    UserTask.prototype.center = function() {
      return this.path.bounds.center;
    };

    return UserTask;

  })(Shape);

  ShapeFactory = (function() {
    var objects;

    function ShapeFactory() {}

    objects = {
      "user-task": UserTask,
      "start-event": StartEvent,
      "end-event": EndEvent
    };

    ShapeFactory.from = function(type, coord, data) {
      var shape;

      return shape = new objects[type]("xaxa", coord, data);
    };

    return ShapeFactory;

  })();

  loadMenu = function(url) {
    return $.ajax(url, {
      dataType: 'json',
      type: 'GET',
      success: function(resp) {
        var menuItems,
          _this = this;

        menuItems = $t.menuItem(resp['palette']);
        $('#palette').append(menuItems);
        $('.draggable').draggable({
          revert: true,
          revertDuration: 10,
          cursorAt: {
            left: 1,
            top: 1
          },
          cursor: "default"
        });
        return $('#editorCanvas').droppable({
          accept: ".draggable",
          drop: function(event, ui) {
            var cp, elem, pos;

            pos = {
              left: event.pageX,
              top: event.pageY
            };
            cp = $('#editorCanvas').position();
            elem = ShapeFactory.from(ui.draggable.attr('data-type'), {
              x: pos.left - cp.left,
              y: pos.top - cp.top
            });
            elem.draw();
            return $p.view.draw();
          }
        });
      }
    });
  };

  loadTemplates = function(url) {
    var _this = this;

    return $.when($.get(url, null, null, 'html')).done(function(resp) {
      return $(resp).each(function(item) {
        $.templates(this.id, $(this).html());
        return this;
      });
    });
  };

  Utils = (function() {
    function Utils() {}

    Utils.add = function(p1, p2) {
      var ret;

      return ret = {
        x: p1.x + p2.x,
        y: p1.y + p2.y
      };
    };

    Utils.minus = function(p1, p2) {
      return new $p.Point(p1.x - p2.x, p1.y - p2.y);
    };

    Utils.s4 = function() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    };

    return Utils;

  })();

}).call(this);
