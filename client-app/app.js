// Generated by CoffeeScript 1.6.2
(function() {
  var Arrow, ArrowParams, EndEvent, Scene, Shape, ShapeConstants, StartEvent, UserTask, Utils, XYPoint, loadMenu, loadPaper, loadTemplates,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  ArrowParams = {
    LENGTH: 10,
    DEGREE: 155
  };

  Arrow = (function() {
    Arrow.prototype.points = {};

    function Arrow(id, from, to, shape) {
      var arrowEnd, arrowPath, end, intersections, lineEnd, linePath, path, pth, start;

      this.id = id;
      this.from = from;
      this.to = to;
      this.shape = shape;
      end = new $p.Point(this.to.x, this.to.y);
      start = new $p.Point(this.from.x, this.from.y);
      linePath = new $p.Path.Line(start, end);
      linePath.strokeColor = 'black';
      pth = this.shape.visiblePath();
      intersections = linePath.getIntersections(pth);
      lineEnd = intersections[0].point;
      arrowEnd = Utils.minus(lineEnd, start).normalize(ArrowParams.LENGTH);
      arrowPath = new $p.Path([Utils.add(lineEnd, arrowEnd.rotate(ArrowParams.DEGREE)), lineEnd, Utils.add(lineEnd, arrowEnd.rotate(-1 * ArrowParams.DEGREE))]);
      arrowPath.strokeWidth = 0.75;
      arrowPath.fillColor = 'black';
      path = new $p.Group([linePath, arrowPath]);
      path.sendToBack();
      this.points = {
        start: linePath.firstSegment.point,
        end: linePath.lastSegment.point,
        ptr: arrowPath,
        linePath: linePath
      };
    }

    Arrow.prototype.move = function(isStartPt, pos, shape) {
      var endPoint, intersections, pth, vec;

      if (!isStartPt) {
        this.points.ptr.translate(pos);
      }
      pth = this.shape.visiblePath();
      intersections = this.points.linePath.getIntersections(pth);
      if (intersections.length > 0) {
        endPoint = intersections[0].point;
        vec = Utils.minus(endPoint, this.points.start).normalize(ArrowParams.LENGTH);
        this.points.ptr.segments[0].point = Utils.add(endPoint, vec.rotate(ArrowParams.DEGREE));
        this.points.ptr.segments[1].point = endPoint;
        return this.points.ptr.segments[2].point = Utils.add(endPoint, vec.rotate(-1 * ArrowParams.DEGREE));
      }
    };

    return Arrow;

  })();

  loadPaper = function() {
    paper.setup('editorCanvas');
    return window.$p = paper;
  };

  $(function() {
    var a, b, c, i, scene, selected, toConnect, tool;

    loadPaper();
    window.$t = $.render;
    loadTemplates('./templates.html');
    loadMenu('./menu.json');
    a = new StartEvent("test", {
      x: 100,
      y: 100
    });
    b = new EndEvent("test2", {
      x: 350,
      y: 150
    });
    c = new UserTask("userTask", {
      x: 200,
      y: 100
    });
    scene = new Scene;
    scene.add(a);
    scene.add(b);
    scene.add(c);
    scene.draw();
    a.from(c);
    c.from(b);
    i = 1;
    i++;
    $p.view.viewSize = new $p.Size(1200, 1200);
    $p.view.draw();
    tool = new $p.Tool();
    selected = void 0;
    toConnect = void 0;
    tool.onMouseDown = function(event) {
      var element;

      selected = event.item;
      $p.project.activeLayer.selected = false;
      if (selected) {
        selected.editorObj.select();
      }
      if (event.modifiers.shift && !selected) {
        element = new UserTask("userTask" + i, {
          x: event.point.x,
          y: event.point.y
        });
        i++;
        element.draw();
      }
      if (event.modifiers.option && selected) {
        if (!toConnect) {
          return toConnect = selected;
        } else {
          toConnect.editorObj.from(selected.editorObj);
          return toConnect = void 0;
        }
      }
    };
    return tool.onMouseDrag = function(event) {
      if (selected) {
        selected.position.x += event.delta.x;
        selected.position.y += event.delta.y;
        return selected.editorObj.move(event.delta);
      }
    };
  });

  ShapeConstants = {
    strokeColor: 'black'
  };

  XYPoint = (function() {
    function XYPoint(x, y) {
      this.x = x;
      this.y = y;
    }

    return XYPoint;

  })();

  Scene = (function() {
    function Scene(objects) {
      this.objects = objects != null ? objects : [];
    }

    Scene.prototype.add = function(object) {
      return this.objects.push(object);
    };

    Scene.prototype.draw = function() {
      var object, _i, _len, _ref, _results;

      _ref = this.objects;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        object = _ref[_i];
        _results.push(object.draw());
      }
      return _results;
    };

    return Scene;

  })();

  Shape = (function() {
    Shape.prototype.type = void 0;

    Shape.prototype.size = void 0;

    Shape.prototype.fromArrows = void 0;

    Shape.prototype.toArrows = void 0;

    Shape.prototype.path = void 0;

    function Shape(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      this.fromArrows = [];
      this.toArrows = [];
      this.size = {};
      this.path = void 0;
    }

    Shape.prototype.draw = function() {
      throw new Error("Unsupported");
    };

    Shape.prototype.visiblePath = function() {
      var pth;

      if (this.path.children) {
        return pth = this.path.children[0];
      } else {
        return pth = this.path;
      }
    };

    Shape.prototype.center = function() {
      return this.coord;
    };

    Shape.prototype.from = function(shape) {
      var arrow;

      arrow = new Arrow("", this.center(), shape.center(), shape);
      this.fromArrows.push(arrow);
      return shape.toArrows.push(arrow);
    };

    Shape.prototype.select = function() {
      return this.visiblePath().selected = true;
    };

    Shape.prototype.move = function(pos) {
      var arrow, _i, _j, _len, _len1, _ref, _ref1, _results;

      _ref = this.fromArrows;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arrow = _ref[_i];
        arrow.points.start.x += pos.x;
        arrow.points.start.y += pos.y;
        arrow.move(true, pos, this);
      }
      _ref1 = this.toArrows;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        arrow = _ref1[_j];
        arrow.points.end.x += pos.x;
        arrow.points.end.y += pos.y;
        _results.push(arrow.move(false, pos, this));
      }
      return _results;
    };

    return Shape;

  })();

  StartEvent = (function(_super) {
    __extends(StartEvent, _super);

    function StartEvent(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      StartEvent.__super__.constructor.call(this, this.id, this.coord, this.data);
      this.type = 'start-event';
      this.size.r = 15;
    }

    StartEvent.prototype.draw = function() {
      this.path = new $p.Path.Circle(new $p.Point(this.coord.x, this.coord.y), this.size.r);
      this.path.fillColor = 'black';
      return this.path.editorObj = this;
    };

    return StartEvent;

  })(Shape);

  EndEvent = (function(_super) {
    __extends(EndEvent, _super);

    function EndEvent(id, coord, data) {
      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      EndEvent.__super__.constructor.call(this, this.id, this.coord, this.data);
      this.type = 'end-event';
      this.size.r = 15;
    }

    EndEvent.prototype.draw = function() {
      this.path = new $p.Path.Circle(new $p.Point(this.coord.x, this.coord.y), this.size.r);
      this.path.fillColor = 'white';
      this.path.strokeColor = 'black';
      return this.path.editorObj = this;
    };

    return EndEvent;

  })(Shape);

  UserTask = (function(_super) {
    __extends(UserTask, _super);

    UserTask.prototype.path = void 0;

    function UserTask(id, coord, data) {
      var path;

      this.id = id;
      this.coord = coord;
      this.data = data != null ? data : {};
      UserTask.__super__.constructor.call(this, this.id, this.coord, this.data);
      path = void 0;
      this.type = 'user-task';
      this.size = {
        x: 100,
        y: 60
      };
    }

    UserTask.prototype.draw = function() {
      var g, pth, rect, txt;

      rect = new $p.Rectangle(new $p.Point(this.coord.x, this.coord.y), new $p.Size(this.size));
      pth = new $p.Path.RoundRectangle(rect, new $p.Size(5, 5));
      pth.strokeColor = 'black';
      pth.fillColor = '#DCECB5';
      txt = new $p.PointText(pth.bounds.leftCenter);
      txt.fillColor = 'black';
      txt.content = this.id;
      txt.bounds.x = txt.bounds.x + 10;
      txt.position.y = txt.bounds.y + txt.bounds.height / 1.5;
      g = new $p.Group([pth, txt]);
      g.applyMatrix = true;
      this.path = g;
      return this.path.editorObj = this;
    };

    UserTask.prototype.center = function() {
      return this.path.bounds.center;
    };

    return UserTask;

  })(Shape);

  loadMenu = function(url) {
    return $.ajax(url, {
      dataType: 'json',
      type: 'GET',
      success: function(resp) {
        var menuItems;

        menuItems = $t.menuItem(resp['palette']);
        return $('#palette').append(menuItems);
      }
    });
  };

  loadTemplates = function(url) {
    var _this = this;

    return $.when($.get(url, null, null, 'html')).done(function(resp) {
      return $(resp).each(function(item) {
        $.templates(this.id, $(this).html());
        return this;
      });
    });
  };

  Utils = (function() {
    function Utils() {}

    Utils.add = function(p1, p2) {
      var ret;

      return ret = {
        x: p1.x + p2.x,
        y: p1.y + p2.y
      };
    };

    Utils.minus = function(p1, p2) {
      return new $p.Point(p1.x - p2.x, p1.y - p2.y);
    };

    return Utils;

  })();

}).call(this);
